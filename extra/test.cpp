#include <stdint.h>
#include <iostream>
#include <string.h>

struct Font
{
  /**
   * @brief Datatype for a bitmap font for rendering text
   * @details Datatype for storing information about how a font should be used to render correctly. Instances of this struct do not need to be manually constructed unless you wish to use your own fonts.
   *
   * @param map An array of the bitmap font data stored in PROGMEM
   * @param width The width in pixels of a single glyph
   * @param height The height in pixels of a single glyph
   * @param length How many characters appear in the font
   * @param offset Skip this many characters in the array, useful for cases like ASCII where codes below 32 are non-printable characters
   */
  Font(const uint8_t* const map, const int16_t width, const int16_t height, const size_t length, const size_t offset)
  : charmap(map)
  , charwidth(width)
  , charheight(height)
  , maplength(length)
  , mapoffset(offset)
  {}

  const uint8_t* const charmap;
  const int16_t charwidth;
  const int16_t charheight;

  const size_t maplength;
  const size_t mapoffset;
};

const uint8_t font3x5_data[96 * 3] = {
  0x00, 0x00, 0x00, //
  0x00, 0x2e, 0x00, // !
  0x06, 0x00, 0x06, // "
  0x3e, 0x14, 0x3e, // #
  0x0c, 0x36, 0x18, // $
  0x32, 0x08, 0x26, // %
  0x14, 0x2a, 0x34, // &
  0x00, 0x06, 0x00, // '
  0x00, 0x1c, 0x22, // (
  0x22, 0x1c, 0x00, // )
  0x14, 0x08, 0x14, // *
  0x08, 0x1c, 0x08, // +
  0x40, 0x60, 0x00, // ,
  0x08, 0x08, 0x08, // -
  0x00, 0x20, 0x00, // .
  0x60, 0x1c, 0x02, // /
  0x3e, 0x22, 0x3e, // 0
  0x24, 0x3e, 0x20, // 1
  0x32, 0x2a, 0x26, // 2
  0x22, 0x2a, 0x3e, // 3
  0x0e, 0x08, 0x3e, // 4
  0x2e, 0x2a, 0x3a, // 5
  0x3e, 0x2a, 0x3a, // 6
  0x02, 0x3a, 0x06, // 7
  0x3e, 0x2a, 0x3e, // 8
  0x2e, 0x2a, 0x3e, // 9
  0x00, 0x14, 0x00, // :
  0x40, 0x64, 0x00, // ;
  0x08, 0x14, 0x22, // <
  0x14, 0x14, 0x14, // =
  0x22, 0x14, 0x08, // >
  0x02, 0x2a, 0x06, // ?
  0x3e, 0x22, 0x2e, // @
  0x3e, 0x0a, 0x3e, // A
  0x3e, 0x2a, 0x36, // B
  0x3e, 0x22, 0x22, // C
  0x3e, 0x22, 0x1c, // D
  0x3e, 0x2a, 0x22, // E
  0x3e, 0x0a, 0x02, // F
  0x3e, 0x22, 0x3a, // G
  0x3e, 0x08, 0x3e, // H
  0x22, 0x3e, 0x22, // I
  0x30, 0x20, 0x3e, // J
  0x3e, 0x08, 0x36, // K
  0x3e, 0x20, 0x20, // L
  0x3e, 0x04, 0x3e, // M
  0x3c, 0x08, 0x1e, // N
  0x3e, 0x22, 0x3e, // O
  0x3e, 0x0a, 0x0e, // P
  0x3e, 0x22, 0x7e, // Q
  0x3e, 0x0a, 0x34, // R
  0x2e, 0x2a, 0x3a, // S
  0x02, 0x3e, 0x02, // T
  0x3e, 0x20, 0x3e, // U
  0x1e, 0x20, 0x1e, // V
  0x3e, 0x10, 0x3e, // W
  0x36, 0x08, 0x36, // X
  0x06, 0x38, 0x06, // Y
  0x32, 0x2a, 0x26, // Z
  0x00, 0x3e, 0x22, // [
  0x02, 0x1c, 0x60, // "\"
  0x22, 0x3e, 0x00, // ]
  0x04, 0x02, 0x04, // ^
  0x40, 0x40, 0x40, // _
  0x00, 0x02, 0x00, // `
  0x3e, 0x0a, 0x3e, // a
  0x3e, 0x2a, 0x36, // b
  0x3e, 0x22, 0x22, // c
  0x3e, 0x22, 0x1c, // d
  0x3e, 0x2a, 0x22, // e
  0x3e, 0x0a, 0x02, // f
  0x3e, 0x22, 0x3a, // g
  0x3e, 0x08, 0x3e, // h
  0x22, 0x3e, 0x22, // i
  0x30, 0x20, 0x3e, // j
  0x3e, 0x08, 0x36, // k
  0x3e, 0x20, 0x20, // l
  0x3e, 0x04, 0x3e, // m
  0x3c, 0x08, 0x1e, // n
  0x3e, 0x22, 0x3e, // o
  0x3e, 0x0a, 0x0e, // p
  0x3e, 0x22, 0x7e, // q
  0x3e, 0x0a, 0x34, // r
  0x2e, 0x2a, 0x3a, // s
  0x02, 0x3e, 0x02, // t
  0x3e, 0x20, 0x3e, // u
  0x1e, 0x20, 0x1e, // v
  0x3e, 0x10, 0x3e, // w
  0x36, 0x08, 0x36, // x
  0x06, 0x38, 0x06, // y
  0x32, 0x2a, 0x26, // z
  0x08, 0x3e, 0x22, // {
  0x00, 0x7e, 0x00, // |
  0x22, 0x3e, 0x08, // }
  0x02, 0x06, 0x04, // ~
  0x00, 0x00, 0x00
};

/**
 * @var 3 by 5 pixel font
 */
static Font font3x5 = {
  font3x5_data,
  3,
  5,
  96,
  32
};


const uint8_t font5x7_data[96 * 5] = {
  0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x5F, 0x00, 0x00,
  0x00, 0x07, 0x00, 0x07, 0x00,
  0x14, 0x7F, 0x14, 0x7F, 0x14,
  0x24, 0x2A, 0x7F, 0x2A, 0x12,
  0x23, 0x13, 0x08, 0x64, 0x62,
  0x36, 0x49, 0x56, 0x20, 0x50,
  0x00, 0x08, 0x07, 0x03, 0x00,
  0x00, 0x1C, 0x22, 0x41, 0x00,
  0x00, 0x41, 0x22, 0x1C, 0x00,
  0x2A, 0x1C, 0x7F, 0x1C, 0x2A,
  0x08, 0x08, 0x3E, 0x08, 0x08,
  0x00, 0x80, 0x70, 0x30, 0x00,
  0x08, 0x08, 0x08, 0x08, 0x08,
  0x00, 0x00, 0x60, 0x60, 0x00,
  0x20, 0x10, 0x08, 0x04, 0x02,
  0x3E, 0x51, 0x49, 0x45, 0x3E,
  0x00, 0x42, 0x7F, 0x40, 0x00,
  0x72, 0x49, 0x49, 0x49, 0x46,
  0x21, 0x41, 0x49, 0x4D, 0x33,
  0x18, 0x14, 0x12, 0x7F, 0x10,
  0x27, 0x45, 0x45, 0x45, 0x39,
  0x3C, 0x4A, 0x49, 0x49, 0x31,
  0x41, 0x21, 0x11, 0x09, 0x07,
  0x36, 0x49, 0x49, 0x49, 0x36,
  0x46, 0x49, 0x49, 0x29, 0x1E,
  0x00, 0x00, 0x14, 0x00, 0x00,
  0x00, 0x40, 0x34, 0x00, 0x00,
  0x00, 0x08, 0x14, 0x22, 0x41,
  0x14, 0x14, 0x14, 0x14, 0x14,
  0x00, 0x41, 0x22, 0x14, 0x08,
  0x02, 0x01, 0x59, 0x09, 0x06,
  0x3E, 0x41, 0x5D, 0x59, 0x4E,
  0x7C, 0x12, 0x11, 0x12, 0x7C,
  0x7F, 0x49, 0x49, 0x49, 0x36,
  0x3E, 0x41, 0x41, 0x41, 0x22,
  0x7F, 0x41, 0x41, 0x41, 0x3E,
  0x7F, 0x49, 0x49, 0x49, 0x41,
  0x7F, 0x09, 0x09, 0x09, 0x01,
  0x3E, 0x41, 0x41, 0x51, 0x73,
  0x7F, 0x08, 0x08, 0x08, 0x7F,
  0x00, 0x41, 0x7F, 0x41, 0x00,
  0x20, 0x40, 0x41, 0x3F, 0x01,
  0x7F, 0x08, 0x14, 0x22, 0x41,
  0x7F, 0x40, 0x40, 0x40, 0x40,
  0x7F, 0x02, 0x1C, 0x02, 0x7F,
  0x7F, 0x04, 0x08, 0x10, 0x7F,
  0x3E, 0x41, 0x41, 0x41, 0x3E,
  0x7F, 0x09, 0x09, 0x09, 0x06,
  0x3E, 0x41, 0x51, 0x21, 0x5E,
  0x7F, 0x09, 0x19, 0x29, 0x46,
  0x26, 0x49, 0x49, 0x49, 0x32,
  0x03, 0x01, 0x7F, 0x01, 0x03,
  0x3F, 0x40, 0x40, 0x40, 0x3F,
  0x1F, 0x20, 0x40, 0x20, 0x1F,
  0x3F, 0x40, 0x38, 0x40, 0x3F,
  0x63, 0x14, 0x08, 0x14, 0x63,
  0x03, 0x04, 0x78, 0x04, 0x03,
  0x61, 0x59, 0x49, 0x4D, 0x43,
  0x00, 0x7F, 0x41, 0x41, 0x41,
  0x02, 0x04, 0x08, 0x10, 0x20,
  0x00, 0x41, 0x41, 0x41, 0x7F,
  0x04, 0x02, 0x01, 0x02, 0x04,
  0x40, 0x40, 0x40, 0x40, 0x40,
  0x00, 0x03, 0x07, 0x08, 0x00,
  0x20, 0x54, 0x54, 0x78, 0x40,
  0x7F, 0x28, 0x44, 0x44, 0x38,
  0x38, 0x44, 0x44, 0x44, 0x28,
  0x38, 0x44, 0x44, 0x28, 0x7F,
  0x38, 0x54, 0x54, 0x54, 0x18,
  0x00, 0x08, 0x7E, 0x09, 0x02,
  0x18, 0xA4, 0xA4, 0x9C, 0x78,
  0x7F, 0x08, 0x04, 0x04, 0x78,
  0x00, 0x44, 0x7D, 0x40, 0x00,
  0x20, 0x40, 0x40, 0x3D, 0x00,
  0x7F, 0x10, 0x28, 0x44, 0x00,
  0x00, 0x41, 0x7F, 0x40, 0x00,
  0x7C, 0x04, 0x78, 0x04, 0x78,
  0x7C, 0x08, 0x04, 0x04, 0x78,
  0x38, 0x44, 0x44, 0x44, 0x38,
  0xFC, 0x18, 0x24, 0x24, 0x18,
  0x18, 0x24, 0x24, 0x18, 0xFC,
  0x7C, 0x08, 0x04, 0x04, 0x08,
  0x48, 0x54, 0x54, 0x54, 0x24,
  0x04, 0x04, 0x3F, 0x44, 0x24,
  0x3C, 0x40, 0x40, 0x20, 0x7C,
  0x1C, 0x20, 0x40, 0x20, 0x1C,
  0x3C, 0x40, 0x30, 0x40, 0x3C,
  0x44, 0x28, 0x10, 0x28, 0x44,
  0x4C, 0x90, 0x90, 0x90, 0x7C,
  0x44, 0x64, 0x54, 0x4C, 0x44,
  0x00, 0x08, 0x36, 0x41, 0x00,
  0x00, 0x00, 0x77, 0x00, 0x00,
  0x00, 0x41, 0x36, 0x08, 0x00,
  0x02, 0x01, 0x02, 0x04, 0x02
};

/**
 * @var 5 by 7 pixel font
 */
static Font font5x7 = {
  font5x7_data,
  5,
  7,
  96,
  32
};


template <typename T>
T modp(const T a, const T b)
{
  return (((a % b) + b) % b);
}

class TextCommand
{
public:

  TextCommand(const int16_t x, const int16_t y, const char* const text, const Font& font, int16_t size) :
  _x(x), _y(y), txt(text), length(strlen(text)), fnt(font), fontsize(size)
  {
  }

  static uint8_t process(void* command, const uint8_t input, const int16_t x, const int16_t y)
  {
    TextCommand* tc = (TextCommand*)command;
    const char* const text = tc->txt;
    const Font& font = tc->fnt;

    // out of x-bounds
    if (x < tc->_x || x >= tc->_x + (font.charwidth + 1) * tc->fontsize * tc->length)
      return input;

    // out of y-bounds
    if (y < tc->_y || y >= tc->_y + font.charheight * tc->fontsize)
      return input;

    // 1px letter spacing
    if (((x - tc->_x) / tc->fontsize + 1) % (font.charwidth + 1) == 0)
      return input;

    const int16_t index = (x - tc->_x) / ((font.charwidth + 1) * tc->fontsize);
    if (index >= tc->length)
      return input;

    const char c = text[index];

    const uint8_t glyph_slice = pgm_read_byte(&(font.charmap[(c - font.mapoffset) * font.charwidth + modp((x - tc->_x) / tc->fontsize, font.charwidth + 1)]));

    if ((glyph_slice >> ((y - tc->_y) / tc->fontsize)) & 1)
      return input & ~(1 << (7 - x % 8));
    return input;
  }

private:
  const int16_t _x, _y;
  const char* const txt;
  const int16_t length;
  const Font& fnt;
  const int16_t fontsize;
};

int main()
{
  TextCommand* commands[] = {
    new TextCommand(0, 8, "ABCDEFGHIJK", font5x7, 1),
    new TextCommand(0, 120, "ABCDE", font3x5, 2),
  };
  const int16_t WIDTH = 152;
  const int16_t HEIGHT = 296;
  uint8_t buf[((WIDTH+1) / 2) * HEIGHT] = {0};

  for (int16_t y = 0; y < HEIGHT; ++y)
  {
    for (int16_t x = 0; x < WIDTH; x += 8)
    {
      buf[y * WIDTH / 8 + x / 8] = 0xff;
      for (int16_t xi = 0; xi < 8; ++xi)
      {
        for (TextCommand* command : commands)
          buf[y * WIDTH / 8 + (x + xi) / 8] = TextCommand::process(command, buf[y * WIDTH / 8 + (x + xi) / 8], x + xi, y);
      }
    }
  }


  for (int16_t y = 0; y < HEIGHT; ++y)
  {
    for (int16_t x = 0; x < WIDTH; x += 8)
    {
      const uint8_t cell = buf[y * WIDTH / 8 + x  / 8];
      for (int16_t xi = 0; xi < 8; ++xi)
      {
        if (!(cell & (1 << (7 - xi))))
          std::cout << "#";
        else
          std::cout << ".";
      }
    }
    std::cout << std::endl;
  }

  for (TextCommand* tc : commands)
    delete tc;
}
